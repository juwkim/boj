# [Silver II] Ключ к шифру - 22156 

[문제 링크](https://www.acmicpc.net/problem/22156) 

### 성능 요약

메모리: 110800 KB, 시간: 104 ms

### 분류

그리디 알고리즘, 문자열

### 제출 일자

2025년 4월 2일 12:43:03

### 문제 설명

<p>Все те сотни лет, в течении которых существуют государства, границы и периодически возникающие конфликты между странами, существует и система шпионажа. Агент, нелегально или легально проживающий в одной стране, отправляет донесения, содержащие в себе государственную тайну, в другую страну. Способы передачи донесений непрерывно меняются. Сто лет назад это были бумажные письма, пятьдесят лет назад — радиограммы, сейчас же есть возможность отправить донесение даже по электронной почте. Однако, одна характерная черта всех донесений не изменилась и не изменится никогда — любое информационное сообщение можно перехватить. Чтобы застраховаться от такой возможности, донесения шифруются так, чтобы прочитать их мог только тот, кому они предназначены. При этом обычно используется некоторый <i>ключ</i> — сравнительно небольшая строка, часто не имеющая смысла, с помощью которой донесение можно расшифровать. А чтобы, в случае поимки агента, он не мог сообщить ключ заинтересованным лицам, каждому донесению соответствует свой ключ, который отправляется вместе с донесением, тоже зашифрованный, но не очень сложным способом. Вам предстоит научиться получать этот ключ по его зашифрованной версии для некоторого алгоритма шифрования.</p>

<p>Чтобы зашифровать непустой ключ <i>s</i>, агент сначала выбирает такую строку <i>t</i>, что строка <i>s</i> является префиксом строки <i>t</i>, а развернутая строка <i>s</i> — суффиксом строки <i>t</i>. При этом в строке <i>t</i> могут быть символы, не имеющие отношения к строке <i>s</i>. После этого слева к строке <i>t</i> дописывается некоторое случайное (возможно, нулевое) количество случайных символов, справа же дописывается точно такое же количество, возможно других, случайных символов. Теперь строка <i>t</i> представляет из себя зашифрованный ключ <i>s</i>.</p>

<p>Понятно, что при попытках восстановить сам ключ, то есть исходную строку <i>s</i>, вариантов может получиться несколько. Поэтому было принято решение, что ключ должен быть самой длинной строкой из всех возможных вариантов, а в случае, если и таких строк несколько — то такой строкой, что количество случайно дописанных слева и справа символов было минимально, то есть строка <i>t</i> имеет максимальную длину. Вам необходимо реализовать алгоритм восстановления ключа <i>s</i> по его зашифрованной версии.</p>

### 입력 

 <p>Первая строка содержит одно целое число <i>n</i> — количество ключей, которые вам необходимо расшифровать. Следующие <i>n</i> строк содержат зашифрованные версии искомых ключей по одной на строке. Каждая зашифрованная версия содержит только строчные буквы латинского алфавита. Суммарная длина всех зашифрованных ключей не превышает 100000 символов. Гарантируется, что для каждой зашифрованной версии существует хотя бы один подходящий непустой ключ.</p>

### 출력 

 <p>Выведите <i>n</i> расшифрованных ключей, по одному на строке.</p>

